## 1. Какого типа команда cd? Попробуйте объяснить, почему она именно такого типа; опишите ход своих мыслей, если считаете что она могла бы быть другого типа.

По умолчанию команда `cd` имеет тип `shell builtin`
```
$ type -t cd
builtin
```
cd является встроенной функцией, по той причине, что НЕ встроеная функция/команда выполняются в новом окружении, по факту будет содан новый процесс. Такое выполнение не может гарантировать "правильность" работы cd, кроме того теряется эффективность.

---

## 2. Какая альтернатива без pipe команде grep <some_string> <some_file> | wc -l? man grep поможет в ответе на этот вопрос.

```
grep -c <some_string> <some_file>
```
---

## 3. Какой процесс с PID 1 является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?

```
$ ps -p 1
1 ?        00:00:00 systemd
```
ответ: `systemd`

---

## 4. Как будет выглядеть команда, которая перенаправит вывод stderr ls на другую сессию терминала?

При условии, что "другая сессия терминала" принадлежит тому же пользователю
```
# можно посмотреть все сессии
$ w
USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
vagrant  pts/0    10.0.2.2         05:22    0.00s  0.04s  0.00s w
vagrant  pts/1    10.0.2.2         10:12    4.00s  0.00s  0.00s -bash

# понять какая в текущем терминале, она же имеет `w` в поле WHAT
$ tty
/dev/pts/0

# и вывести ошибку в другой терминал
$ ls non_existing_directory 2> /dev/pts/1
# во втором терминале появится вывод
ls: cannot access 'non_existing_directory': No such file or directory
```

---

## 5. Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? Приведите работающий пример.
```
# Предварительно создадим файл с таким содержимым
$ echo ~ > home_dir_loc

# После этого можно выполнить
$ la < home_dir_loc > home_dir_content # таким образом содержимо едомашней директории пользователя окажется в файле home_dir_content
```

---

## 6. Получится ли вывести находясь в графическом режиме данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?

Не очень понял что конкретно имеется ввиду под "графический режим"))

Если запустить vagrant и в тоже время tty стандартными средствами VirtualBox, и сделать как-то так: `ls ~ 1> /dev/tty1` в pty vagrant-a, то в tty терминале отобразится вывод команды. Важно что пользователь будет один и тот же.

Даже если установить ту же Ubuntu с графическим интерфейсом и там запустить терминал (pty) и перейти в tty, то команда `ls ~ 1> /dev/tty1` опять-таки отобразит результат своего выполнения в tty. При условии что пользователь тот же.

---

## 7. Выполните команду bash 5>&1. К чему она приведет? Что будет, если вы выполните echo netology > /proc/$$/fd/5? Почему так происходит?

Выполнение команды `bash 5>&1` приведет к тому, что для bash оболочки мы создадим файловый дескриптор 5 и все что будет в него попадать, будет перенаправлено на STDOUT bash, т.е. по сути текущей сессии. При этом в виртуальной фаловой системе /proc в каталоге <pid текущего процесса ($$)>/fd появится файл 5
После того как мы выполним `echo netology > /proc/$$/fd/5`, вывод слова `netology` будет направлен по адресу файлового дескриптора 5 текущей bash сессии, т.е. в STDOUT. Так происходит, потому что все что попадает по адресу файловго дескриптора 5 перенаправляется на STDOUT

---

## 8. Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв при этом отображение stdout на pty?

```
$ find /var/log 3>&1 1>&2 2>&3 | tee errors
```

---

## 9. Что выведет команда cat /proc/$$/environ? Как еще можно получить аналогичный по содержанию вывод?

Команда `cat /proc/$$/environ` выводит все переменные окружения для текущей сессии. Если не ошибаюсь, то аналогичный вывод можно получить командой `printenv`

---

## 10. Используя man, опишите что доступно по адресам /proc/PID/cmdline, /proc/PID/exe.

- `/proc/<PID>/cmdline`: readonly файл содержит полную командную строку для процесса, если только это не зомби процесс. В последнем случае в этом файле ничего нет: то есть чтение этого файла вернет 0 символов. Аргументы командной строки отображаются в этом файле в виде набора строк, разделенных нуль-байтами ('\0'), с последующим нуль-байтом после последней строки.
- `/proc/<PID>/exe`: в Linux 2.2 и более поздних версиях этот файл представляет собой символическую ссылку, содержащую фактический путь к выполняемой команде. В Linux 2.0 и более ранних версиях /proc/[pid]/exe-это указатель на двоичный файл, который был выполнен, и отображается как символическая ссылка.

---

## 11. Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью /proc/cpuinfo.

```
$ cat /proc/cpuinfo | grep sse
... sse4_2 ...
```
---

## 12. При открытии нового окна терминала и vagrant ssh создается новая сессия и выделяется pty. Это можно подтвердить командой tty, которая упоминалась в лекции 3.2. Однако:
   ```
   vagrant@netology1:~$ ssh localhost 'tty'
   not a tty
   ```
   Почитайте, почему так происходит, и как изменить поведение.

По умолчанию, когда мы вызываем `ssh command`, мы вызываем команду на удаленном хосте, в этот момент tty еще не аллоцирован, отсюда и ошибка `not a tty`
Чтобы изменить это поведение, согласно `man ssh`, нужно добавить ключ `-t` для `Force pseudo-terminal allocation`. В таком случае команда отработает корректно.

---

## 13. Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Попробуйте сделать это, воспользовавшись reptyr. Например, так можно перенести в screen процесс, который вы запустили по ошибке в обычной SSH-сессии.
```
$ run_long-running_process # какой-то долгий процесс
$ ps -a # находим pid этого run_long-running_process
$ reptyr <pid> # забираем процесс, например, в новое коно терминала, или в screen, tmux, etc.
```
